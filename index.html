<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>ENIGMA パズル（試作）</title>
<style>
  :root{
    --bg:#f4f4f6;
    --panel:#ffffff;
    --border:#e5e7eb;
  }
  html,body{margin:0;height:100%;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;}
  #wrap{height:100%;display:flex;flex-direction:column;}
  #topbar{background:#111827;color:#fff;padding:10px 12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  #topbar .title{font-weight:900}
  #topbar .hint{opacity:.85;font-size:12px}

  #main{flex:1;min-height:0;display:flex;}
  #left{flex:1;min-width:0;display:flex;flex-direction:column;}
  #canvasWrap{flex:1;min-height:0;position:relative;}
  canvas{width:100%;height:100%;display:block;background:#fff;touch-action:none;}

  /* 指（ドラッグ中だけ表示） */
  #finger{
    position:absolute;width:46px;height:46px;pointer-events:none;display:none;
    transform:translate(-14px,-18px);
    filter: drop-shadow(0 6px 12px rgba(0,0,0,.28));
  }

  /* 下の置き場（山札） */
  #stocks{
    background:var(--panel);
    border-top:1px solid var(--border);
    padding:10px;
    display:grid;
    grid-template-columns:repeat(4, 1fr);
    gap:10px;
  }

  .pile{
    height:84px;
    border:1px solid #d1d5db;
    background:linear-gradient(#fff,#fafafa);
    user-select:none; touch-action:none;
    display:flex; align-items:center; justify-content:center;
    position:relative;
    overflow:hidden;
    cursor:grab;
  }
  .pile:active{cursor:grabbing}
  .pile .count{
    position:absolute; right:8px; bottom:6px;
    font-size:12px; font-variant-numeric:tabular-nums;
    padding:2px 6px; border-radius:10px;
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    color:#111827;
  }
  .pile .badge{
    position:absolute; left:8px; bottom:6px;
    font-size:11px; padding:2px 6px; border-radius:10px;
    background:rgba(255,255,255,.78);
    border:1px solid rgba(0,0,0,.08);
    color:#111827;
  }

  /* iPad対策：clip-path は webkit を追加 */
  .pile.tri{
    clip-path: polygon(50% 10%, 12% 90%, 88% 90%);          /* 上向き三角 */
    -webkit-clip-path: polygon(50% 10%, 12% 90%, 88% 90%);
    border-radius:10px;
  }
  .pile.rho{
    clip-path: polygon(18% 50%, 50% 12%, 82% 50%, 50% 88%);          /* 平行四辺形 */
    -webkit-clip-path: polygon(18% 50%, 50% 12%, 82% 50%, 50% 88%);
    border-radius:10px;
  }

  /* 柄（仮：DW/MW/LW/WW） */
  .tex{position:absolute; inset:0;}
  .DW{background:#3b2f2a;}
  .MW{background:#7a5a3d;}
  .LW{background:#c9a57a;}
  .WW{background:#e9e6df;}
  .DW,.MW,.LW,.WW{position:relative;}
  .DW::after,.MW::after,.LW::after,.WW::after{
    content:""; position:absolute; inset:0; opacity:.22;
    background-image:repeating-linear-gradient(90deg, rgba(255,255,255,.08) 0 2px, rgba(0,0,0,.06) 2px 5px);
    mix-blend-mode:overlay;
  }

  /* 右パネル（狭い画面では隠す） */
  #right{
    width:280px; max-width:42vw;
    border-left:1px solid var(--border);
    background:var(--panel);
    padding:10px; box-sizing:border-box; overflow:auto;
  }
  #right h3{margin:6px 0 6px;font-size:14px}
  #right p{margin:6px 0;font-size:12px;line-height:1.45;color:#374151}
  .btnrow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{border:1px solid #d1d5db;background:#fff;border-radius:10px;padding:8px 10px;font-size:12px;cursor:pointer;}
  button:active{transform:translateY(1px)}
  #stats{margin-top:10px;font-size:11px;opacity:.85}
  #err{margin-top:10px;padding:8px 10px;border-radius:10px;background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;font-size:12px;white-space:pre-wrap;display:none;}

  @media (max-width: 1024px){
    #right{display:none;}
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div class="title">ENIGMA（試作）</div>
    <div class="hint">山札からドラッグ / 六角内だけ吸い付き / タップ：60°回転 / ダブルタップ：削除（在庫に戻る）</div>
  </div>

  <div id="main">
    <div id="left">
      <div id="canvasWrap">
        <canvas id="c"></canvas>

        <svg id="finger" viewBox="0 0 64 64" aria-hidden="true">
          <path d="M22 55c-4-2-8-8-8-14V18c0-3 2-5 5-5s5 2 5 5v12"
                fill="#ffe3c4" stroke="#111827" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M24 30V12c0-3 2-5 5-5s5 2 5 5v16"
                fill="#ffe3c4" stroke="#111827" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M34 28V14c0-3 2-5 5-5s5 2 5 5v18"
                fill="#ffe3c4" stroke="#111827" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M44 32V20c0-3 2-5 5-5s5 2 5 5v19c0 9-7 18-15 18H30c-3 0-6-1-8-2z"
                fill="#ffe3c4" stroke="#111827" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>

      <div id="stocks"></div>
    </div>

    <div id="right">
      <h3>操作</h3>
      <p>
        ・下の山札（▶ / ◀▶）からドラッグして出す（8種×各16枚）<br>
        ・六角の中：点・線が吸い付く（スナップ）<br>
        ・六角の外：自由配置（スナップなし）<br>
        ・タップ：60°時計回り回転<br>
        ・ダブルタップ：削除（在庫に戻る）
      </p>
      <div class="btnrow">
        <button id="reset">リセット</button>
        <button id="demo">適当に置く（デモ）</button>
      </div>
      <div id="stats"></div>
      <div id="err"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const errBox = document.getElementById('err');
  const showErr = (msg) => { errBox.style.display='block'; errBox.textContent = msg; };
  window.addEventListener('error', (e)=>showErr("エラーで停止しました:\n"+(e.message || e.error || e)));
  window.addEventListener('unhandledrejection', (e)=>showErr("エラーで停止しました（Promise）:\n"+(e.reason || e)));

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const finger = document.getElementById('finger');
  const stocksEl = document.getElementById('stocks');

  const SQRT3 = Math.sqrt(3);

  // ===== 調整ノブ =====
  const SIDE = 2;          // 盤面（六角）のサイズ
  const SCALE_K = 4.0;     // 小さいほど盤面が大きくなる（iPadは3.6〜4.6推奨）
  const SNAP_ONLY_INSIDE = true;
  const ROT_DEG = 90;      // 見た目を90°回転（向き修正）
  // ===================

  function uuid(){
    try{ if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(_){}
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c=>{
      const r=Math.random()*16|0; const v=(c==="x")?r:(r&0x3|0x8); return v.toString(16);
    });
  }

  // axial(q,r) <-> world(x,y)
  function axialToWorld(q, r){ return { x: q + r/2, y: (SQRT3/2) * r }; }
  function worldToAxial(x, y){ const r = (2 / SQRT3) * y; const q = x - r/2; return { q, r }; }

  function axialRound(qf, rf){
    let x=qf, z=rf, y=-x-z;
    let rx=Math.round(x), ry=Math.round(y), rz=Math.round(z);
    const xd=Math.abs(rx-x), yd=Math.abs(ry-y), zd=Math.abs(rz-z);
    if (xd>yd && xd>zd) rx=-ry-rz;
    else if (yd>zd) ry=-rx-rz;
    else rz=-rx-ry;
    return { q: rx, r: rz };
  }

  function rotateAxial(q,r,k){
    let x=q, z=r, y=-x-z;
    k=((k%6)+6)%6;
    for (let i=0;i<k;i++){
      const nx=-z, ny=-x, nz=-y;
      x=nx; y=ny; z=nz;
    }
    return { q:x, r:z };
  }

  const triUp   = (q,r)=>[{q,r},{q:q+1,r},{q,r:r+1}];
  const triDown = (q,r)=>[{q:q+1,r:r+1},{q:q+1,r},{q,r:r+1}];
  function triKey(vs){
    const s = vs.slice().sort((a,b)=>(a.q-b.q)||(a.r-b.r));
    return `${s[0].q},${s[0].r}|${s[1].q},${s[1].r}|${s[2].q},${s[2].r}`;
  }

  function pointInPoly(pt, poly){
    let inside=false;
    for (let i=0,j=poly.length-1;i<poly.length;j=i++){
      const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
      const inter = ((yi>pt.y)!=(yj>pt.y)) && (pt.x < (xj-xi)*(pt.y-yi)/(yj-yi+1e-12)+xi);
      if (inter) inside=!inside;
    }
    return inside;
  }
  function centroidWorld(tri){
    let sx=0, sy=0;
    for (const v of tri){
      const w=axialToWorld(v.q,v.r);
      sx+=w.x; sy+=w.y;
    }
    return { x:sx/3, y:sy/3 };
  }

  function hexVerticesWorld(){
    const R = SIDE*2;
    const verts=[];
    for (let i=0;i<6;i++){
      const ang = (-90 + i*60) * Math.PI/180;
      verts.push({ x:R*Math.cos(ang), y:R*Math.sin(ang) });
    }
    return verts;
  }
  const hexPoly = hexVerticesWorld();
  function isInsideHexWorld(x,y){ return pointInPoly({x,y}, hexPoly); }

  // 盤面セル
  const BoardSet = new Set();
  const BoardTris = [];
  function rebuildBoard(){
    BoardSet.clear(); BoardTris.length=0;
    const lim = SIDE*7;
    for (let q=-lim;q<=lim;q++){
      for (let r=-lim;r<=lim;r++){
        const up=triUp(q,r);
        if (pointInPoly(centroidWorld(up), hexPoly)){ const k=triKey(up); BoardSet.add(k); BoardTris.push(up); }
        const dn=triDown(q,r);
        if (pointInPoly(centroidWorld(dn), hexPoly)){ const k=triKey(dn); BoardSet.add(k); BoardTris.push(dn); }
      }
    }
  }
  rebuildBoard();

  // ピース
  const SHAPES = {
    TRI: { localTris:[triUp(0,0)] },
    RHO: { localTris:[triUp(0,0), triDown(0,0)] } // 当たり判定用
  };
  const PATTERNS = ["DW","MW","LW","WW"];
  const TYPES = [];
  for (const p of PATTERNS) TYPES.push({ typeId:`TRI_${p}`, shape:"TRI", pattern:p });
  for (const p of PATTERNS) TYPES.push({ typeId:`RHO_${p}`, shape:"RHO", pattern:p });

  const stock = {}; for (const t of TYPES) stock[t.typeId]=16;
  const pieces = [];
  let occupied = new Set();

  // 画面変換（表示だけ90°回転）
  let W=0,H=0,scale=40, origin={x:0,y:0};
  const ROT = ROT_DEG * Math.PI / 180;
  const COS = Math.cos(ROT);
  const SIN = Math.sin(ROT);

  const worldToScreen = (x,y) => {
    const xr = x*COS - y*SIN;
    const yr = x*SIN + y*COS;
    return { x: origin.x + xr*scale, y: origin.y + yr*scale };
  };
  const screenToWorld = (sx,sy) => {
    const x = (sx - origin.x)/scale;
    const y = (sy - origin.y)/scale;
    const xr = x*COS + y*SIN;
    const yr = -x*SIN + y*COS;
    return { x: xr, y: yr };
  };

  function resize(){
    const rect=canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width*dpr);
    canvas.height = Math.floor(rect.height*dpr);
    W=canvas.width; H=canvas.height;

    origin = { x: W/2, y: H/2 };
    const minDim = Math.min(rect.width, rect.height);
    scale = (minDim/(SIDE*SCALE_K))*dpr;

    draw();
  }
  window.addEventListener('resize', resize);

  // 仮テクスチャ
  function patternFillStyle(pid){
    patternFillStyle.cache ||= {};
    if (patternFillStyle.cache[pid]) return patternFillStyle.cache[pid];

    const off=document.createElement('canvas'); off.width=36; off.height=36;
    const c=off.getContext('2d');
    const base={DW:"#3b2f2a",MW:"#7a5a3d",LW:"#c9a57a",WW:"#e9e6df"}[pid]||"#999";
    c.fillStyle=base; c.fillRect(0,0,36,36);
    c.globalAlpha=0.22; c.strokeStyle="#000"; c.lineWidth=2;
    for (let x=0;x<36;x+=7){ c.beginPath(); c.moveTo(x,0); c.lineTo(x,36); c.stroke(); }
    c.globalAlpha=0.14; c.strokeStyle="#fff";
    for (let x=4;x<36;x+=11){ c.beginPath(); c.moveTo(x,0); c.lineTo(x,36); c.stroke(); }

    const pat=ctx.createPattern(off,'repeat');
    patternFillStyle.cache[pid]=pat;
    return pat;
  }

  function strokeTri(vs){
    ctx.beginPath();
    for (let i=0;i<3;i++){
      const w=axialToWorld(vs[i].q,vs[i].r);
      const s=worldToScreen(w.x,w.y);
      if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
    }
    ctx.closePath(); ctx.stroke();
  }

  function fillTri(vs, fill, stroke, shadow){
    ctx.save();
    if (shadow){
      const dpr = window.devicePixelRatio||1;
      ctx.shadowColor="rgba(0,0,0,.18)";
      ctx.shadowBlur=10*dpr;
      ctx.shadowOffsetY=5*dpr;
    }
    ctx.beginPath();
    for (let i=0;i<3;i++){
      const w=axialToWorld(vs[i].q,vs[i].r);
      const s=worldToScreen(w.x,w.y);
      if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
    }
    ctx.closePath();
    ctx.fillStyle=fill; ctx.fill();
    ctx.shadowColor="transparent";
    ctx.lineWidth=2*(window.devicePixelRatio||1);
    ctx.strokeStyle=stroke; ctx.stroke();
    ctx.restore();
  }

  function pieceWorldTris(p){
    const shape = SHAPES[p.shape];
    const out=[];
    for (const tri of shape.localTris){
      const vs = tri.map(v=>rotateAxial(v.q, v.r, p.rotK));
      out.push(vs.map(v=>({ q:v.q + p.anchor.q, r:v.r + p.anchor.r })));
    }
    return out;
  }
  function pieceWorldTriKeys(p){
    return pieceWorldTris(p).map(tri=>triKey(tri));
  }

  function canPlace(p){
    const keys = pieceWorldTriKeys(p);
    for (const k of keys){
      if (!BoardSet.has(k)) return false;
      if (occupied.has(k)) return false;
    }
    return true;
  }
  function commitPlace(p){
    if (p.placed && p._keys){ for (const k of p._keys) occupied.delete(k); }
    const keys = pieceWorldTriKeys(p);
    for (const k of keys) occupied.add(k);
    p._keys = keys;
    p.placed = true;
    p.lastValid = { anchor:{...p.anchor}, rotK:p.rotK };
  }
  function unplace(p){
    if (p._keys){ for (const k of p._keys) occupied.delete(k); }
    p._keys=null; p.placed=false;
  }

  // 描画：RHOは「四角形1枚」として描く（中線を消す）
  function drawPiece(p, floating){
    const fill = patternFillStyle(p.pattern);
    const stroke = floating ? "rgba(17,24,39,.65)" : "rgba(17,24,39,.40)";
    const dpr = window.devicePixelRatio||1;

    if (p.shape === "RHO"){
      // 4頂点（軸座標）を回転・移動して四角形で描く
      const vertsLocal = [
        {q:0,r:0},{q:1,r:0},{q:1,r:1},{q:0,r:1}
      ].map(v => rotateAxial(v.q, v.r, p.rotK))
       .map(v => ({ q: v.q + p.anchor.q, r: v.r + p.anchor.r }));

      ctx.save();
      if (floating){
        ctx.shadowColor="rgba(0,0,0,.18)";
        ctx.shadowBlur=10*dpr;
        ctx.shadowOffsetY=5*dpr;
      }
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const w=axialToWorld(vertsLocal[i].q, vertsLocal[i].r);
        const s=worldToScreen(w.x,w.y);
        if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
      }
      ctx.closePath();
      ctx.fillStyle=fill; ctx.fill();
      ctx.shadowColor="transparent";
      ctx.lineWidth=2*dpr;
      ctx.strokeStyle=stroke; ctx.stroke();
      ctx.restore();
      return;
    }

    // TRI
    const tris = pieceWorldTris(p);
    for (const t of tris) fillTri(t, fill, stroke, floating);
  }

  function draw(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle="#f8fafc"; ctx.fillRect(0,0,W,H);

    // ベース板（正方形）
    const sq=6.2*SIDE;
    const a=worldToScreen(-sq/2,-sq/2);
    const b=worldToScreen( sq/2, sq/2);
    ctx.fillStyle="#efe7db"; ctx.fillRect(a.x,a.y,b.x-a.x,b.y-a.y);
    ctx.strokeStyle="rgba(17,24,39,.25)";
    ctx.lineWidth=2*(window.devicePixelRatio||1);
    ctx.strokeRect(a.x,a.y,b.x-a.x,b.y-a.y);

    // 六角枠
    ctx.beginPath();
    hexPoly.forEach((v,i)=>{
      const s=worldToScreen(v.x,v.y);
      if (i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
    });
    ctx.closePath();
    ctx.fillStyle="#fff"; ctx.fill();
    ctx.strokeStyle="rgba(17,24,39,.40)";
    ctx.lineWidth=3*(window.devicePixelRatio||1);
    ctx.stroke();

    // 仕切り（濃く太く）
    ctx.strokeStyle="rgba(17,24,39,.18)";
    ctx.lineWidth=1.4*(window.devicePixelRatio||1);
    for (const tri of BoardTris) strokeTri(tri);

    // ピース
    const placed=pieces.filter(p=>p.placed);
    const floating=pieces.filter(p=>!p.placed);
    for (const p of placed) drawPiece(p,false);
    for (const p of floating) drawPiece(p,true);

    const stats = document.getElementById('stats');
    if (stats){
      stats.textContent = `盤面セル: ${BoardSet.size} / 使用中: ${occupied.size} / ピース数: ${pieces.length}`;
    }
  }

  // 山札
  function renderStocks(){
    stocksEl.innerHTML="";
    for (const t of TYPES){
      const div=document.createElement('div');
      div.className = "pile " + (t.shape==="TRI" ? "tri" : "rho");

      const tex=document.createElement('div');
      tex.className = "tex " + t.pattern;
      div.appendChild(tex);

      const badge=document.createElement('div');
      badge.className="badge";
      badge.textContent = (t.shape==="TRI" ? "▶" : "◀▶");
      div.appendChild(badge);

      const count=document.createElement('div');
      count.className="count";
      count.textContent = stock[t.typeId];
      div.appendChild(count);

      div.addEventListener('pointerdown', (e)=>onPilePointerDown(e, t));
      stocksEl.appendChild(div);
    }
  }

  // 入力
  let drag=null;
  let lastTap={time:0,pieceId:null};

  function onPilePointerDown(e, t){
    e.preventDefault();
    if (stock[t.typeId] <= 0) return;

    stock[t.typeId]--;
    renderStocks();

    const p={
      id: uuid(),
      typeId: t.typeId,
      shape: t.shape,
      pattern: t.pattern,
      anchor: {q:0, r:0},
      rotK: 0,
      placed:false,
      _keys:null,
      lastValid:null,
      _inside:false
    };

    // pointer位置へ出す（まず自由配置）
    const rect=canvas.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    const sx=(e.clientX-rect.left)*dpr;
    const sy=(e.clientY-rect.top)*dpr;
    const w=screenToWorld(sx,sy);
    const frac=worldToAxial(w.x,w.y);
    p.anchor = { q: frac.q, r: frac.r };

    pieces.push(p);
    startDrag(e,p);
  }

  function startDrag(e,p){
    const rect=canvas.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    const sx=(e.clientX-rect.left)*dpr;
    const sy=(e.clientY-rect.top)*dpr;
    const w=screenToWorld(sx,sy);

    const aw=axialToWorld(p.anchor.q,p.anchor.r);
    drag = { pieceId:p.id, offset:{x:w.x-aw.x, y:w.y-aw.y}, moved:false, start:{sx,sy} };

    finger.style.display="block";
    finger.style.left=(sx/dpr)+"px";
    finger.style.top=(sy/dpr)+"px";

    canvas.setPointerCapture(e.pointerId);
    draw();
  }

  function pointInTri(P,A,B,C){
    const v0={x:C.x-A.x,y:C.y-A.y};
    const v1={x:B.x-A.x,y:B.y-A.y};
    const v2={x:P.x-A.x,y:P.y-A.y};
    const dot00=v0.x*v0.x+v0.y*v0.y;
    const dot01=v0.x*v1.x+v0.y*v1.y;
    const dot02=v0.x*v2.x+v0.y*v2.y;
    const dot11=v1.x*v1.x+v1.y*v1.y;
    const dot12=v1.x*v2.x+v1.y*v2.y;
    const inv=1/(dot00*dot11-dot01*dot01+1e-12);
    const u=(dot11*dot02-dot01*dot12)*inv;
    const v=(dot00*dot12-dot01*dot02)*inv;
    return u>=-1e-6 && v>=-1e-6 && (u+v)<=1+1e-6;
  }

  function findPieceAtScreen(sx,sy){
    for (let i=pieces.length-1;i>=0;i--){
      const p=pieces[i];

      // RHOは四角形で当たり判定（TRIは三角）
      if (p.shape==="RHO"){
        const verts = [
          {q:0,r:0},{q:1,r:0},{q:1,r:1},{q:0,r:1}
        ].map(v => rotateAxial(v.q, v.r, p.rotK))
         .map(v => ({ q: v.q + p.anchor.q, r: v.r + p.anchor.r }))
         .map(v => {
           const w=axialToWorld(v.q,v.r);
           return worldToScreen(w.x,w.y);
         });
        // 四角形を2三角に分けて判定
        const P={x:sx,y:sy};
        if (pointInTri(P, verts[0], verts[1], verts[2]) || pointInTri(P, verts[0], verts[2], verts[3])) return p;
      } else {
        const tris=pieceWorldTris(p);
        for (const tri of tris){
          const A=axialToWorld(tri[0].q,tri[0].r); const As=worldToScreen(A.x,A.y);
          const B=axialToWorld(tri[1].q,tri[1].r); const Bs=worldToScreen(B.x,B.y);
          const C=axialToWorld(tri[2].q,tri[2].r); const Cs=worldToScreen(C.x,C.y);
          if (pointInTri({x:sx,y:sy}, As,Bs,Cs)) return p;
        }
      }
    }
    return null;
  }

  function deletePiece(p){
    if (p.placed) unplace(p);
    stock[p.typeId] = (stock[p.typeId]||0) + 1;
    const idx=pieces.findIndex(x=>x.id===p.id);
    if (idx>=0) pieces.splice(idx,1);
    renderStocks();
  }

  function rotatePiece(p){
    const prevRot=p.rotK;
    const prevAnchor={...p.anchor};
    const wasPlaced=p.placed;
    if (wasPlaced) unplace(p);

    p.rotK = (p.rotK+1)%6;

    if (p._inside){
      if (canPlace(p)){
        commitPlace(p);
      } else {
        p.rotK=prevRot; p.anchor=prevAnchor;
        if (wasPlaced && canPlace(p)) commitPlace(p);
      }
    } else {
      p.placed=false; p._keys=null;
    }
  }

  canvas.addEventListener('pointerdown', (e)=>{
    const rect=canvas.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    const sx=(e.clientX-rect.left)*dpr;
    const sy=(e.clientY-rect.top)*dpr;

    const p=findPieceAtScreen(sx,sy);
    if (!p) return;

    const now=performance.now();
    if (now-lastTap.time<320 && lastTap.pieceId===p.id){
      deletePiece(p);
      lastTap={time:0,pieceId:null};
      draw();
      return;
    }
    lastTap={time:now,pieceId:p.id};

    if (p.placed) unplace(p);
    startDrag(e,p);
  });

  canvas.addEventListener('pointermove', (e)=>{
    if (!drag) return;
    const rect=canvas.getBoundingClientRect();
    const dpr=window.devicePixelRatio||1;
    const sx=(e.clientX-rect.left)*dpr;
    const sy=(e.clientY-rect.top)*dpr;

    finger.style.left=(sx/dpr)+"px";
    finger.style.top=(sy/dpr)+"px";

    const p=pieces.find(x=>x.id===drag.pieceId);
    if (!p) return;

    const dx=sx-drag.start.sx, dy=sy-drag.start.sy;
    if (!drag.moved && (dx*dx+dy*dy)>(9*dpr)*(9*dpr)) drag.moved=true;

    const w=screenToWorld(sx,sy);
    const target={ x:w.x-drag.offset.x, y:w.y-drag.offset.y };
    const frac=worldToAxial(target.x,target.y);

    if (SNAP_ONLY_INSIDE){
      const inside = isInsideHexWorld(target.x, target.y);
      p._inside = inside;
      if (inside){
        p.anchor = axialRound(frac.q, frac.r);
      } else {
        p.anchor = { q: frac.q, r: frac.r };
      }
    } else {
      p.anchor = axialRound(frac.q, frac.r);
      p._inside = true;
    }

    draw();
  });

  canvas.addEventListener('pointerup', ()=>{
    if (!drag) return;
    const p=pieces.find(x=>x.id===drag.pieceId);
    const moved=drag.moved;
    drag=null;
    finger.style.display="none";
    if (!p){ draw(); return; }

    if (!moved){
      rotatePiece(p);
      draw();
      return;
    }

    if (p._inside){
      if (canPlace(p)){
        commitPlace(p);
      } else if (p.lastValid){
        p.anchor={...p.lastValid.anchor};
        p.rotK=p.lastValid.rotK;
        commitPlace(p);
      } else {
        deletePiece(p);
      }
    } else {
      p.placed=false;
      p._keys=null;
    }

    draw();
  });

  document.getElementById('reset').addEventListener('click', ()=>{
    pieces.length=0; occupied=new Set();
    for (const t of TYPES) stock[t.typeId]=16;
    renderStocks(); draw();
  });

  document.getElementById('demo').addEventListener('click', ()=>{
    const rand=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    const tries=50;

    for (let i=0;i<24;i++){
      const t=TYPES[Math.floor(Math.random()*TYPES.length)];
      if (stock[t.typeId]<=0) continue;

      stock[t.typeId]--;
      const p={id:uuid(), typeId:t.typeId, shape:t.shape, pattern:t.pattern,
               anchor:{q:0,r:0}, rotK:rand(0,5), placed:false, _keys:null, lastValid:null, _inside:true};
      pieces.push(p);

      let ok=false;
      for (let k=0;k<tries;k++){
        p.anchor={q:rand(-12,12), r:rand(-12,12)};
        p.rotK=rand(0,5);
        p._inside=true;
        if (canPlace(p)){ commitPlace(p); ok=true; break; }
      }
      if (!ok){ stock[t.typeId]++; pieces.pop(); }
    }
    renderStocks(); draw();
  });

  // 初期化
  renderStocks();
  resize();
})();
</script>
</body>
</html>
